package org.unicode.icu.tool.cldrtoicu.ant;

import static com.google.common.base.Preconditions.checkArgument;
import static java.util.Optional.empty;
import static org.apache.tools.ant.Project.MSG_DEBUG;
import static org.apache.tools.ant.Project.MSG_ERR;
import static org.apache.tools.ant.Project.MSG_INFO;
import static org.apache.tools.ant.Project.MSG_VERBOSE;
import static org.apache.tools.ant.Project.MSG_WARN;

import java.io.PrintStream;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.Map;
import java.util.Optional;

import org.apache.tools.ant.BuildException;
import org.apache.tools.ant.DefaultLogger;
import org.apache.tools.ant.Project;
import org.apache.tools.ant.ProjectHelper;

import com.google.common.base.CaseFormat;
import com.google.common.base.Converter;
import com.google.common.collect.ImmutableMap;

/**
 * Run the CLDR-to-ICU conversion tool programmatically, as opposed to using Ant from the command
 * line.
 */
public final class AntRunner {
    /**
     * An example entry point which runs the CLDR-to-ICU Ant task from the current working
     * directory with normal logging. For programmatic use, prefer to call {@link #runCldrToIcu}()
     * or {@link #runQuietly}() directly.
     */
    public static void main(String[] args) {
        runCldrToIcu(Paths.get("."), ImmutableMap.of(), LogPolicy.INFO, empty(), empty());
    }

    // Expected build file in base directory.
    private static final String BUILD_XML = "build-icu-data.xml";

    /** Keys for properties to be overridden in the Ant task. */
    public enum AntProperty {
        /**
         * The output directory into which to write the converted ICU data. By default
         * this will overwrite (without deletion) the ICU data files in this ICU release,
         * so it is recommended that for testing, it be set to another value.
         */
        OUT_DIR,
        /** The directory in which the additional ICU XML data is stored. */
        SPECIALS_DIR,
        /** An override for the CLDR version string to be used in generated data. */
        CLDR_VERSION,
        /**
         * The minimum draft status for CLDR data to be used in the conversion. See
         * CldrDraftStatus for more details.
         */
        MIN_DRAFT_STATUS,
        /**
         * A regular expression to match the locale IDs to be generated (useful for
         * debugging specific regions). This is applied after locale ID specifications
         * have been expanded into full locale IDs, so the value "en" will NOT match
         * "en_GB" or "en_001" etc.
         */
        LOCALE_ID_FILTER,
        /** Whether to synthetically generate "pseudo locale" data ("en_XA" and "ar_XB"). */
        INCLUDE_PSEUDO_LOCALES,
        /**
         * List of output "types" to be generated (e.g. "rbnf,plurals,locales"); an empty
         * list means "build everything".
         *
         * Note that the grouping of types is based on the legacy converter behaviour and
         * is not always directly associated with an output directory (e.g. "locales"
         * produces locale data for curr/, lang/, main/, region/, unit/, zone/ but NOT
         * coll/, brkitr/ or rbnf/).
         */
        OUTPUT_TYPES,
        /**
         * Override to force the 'clean' task to delete files it cannot determine to be
         * auto-generated by this tool. This is useful if the file header changes since
         * the heading is what's used to recognize auto-generated files.
         */
        FORCE_DELETE;

        private static final Converter<String, String> PROPERTY_NAME_CONVERTER =
            CaseFormat.UPPER_UNDERSCORE.converterTo(CaseFormat.LOWER_CAMEL);

        public String getPropertyName() {
            return PROPERTY_NAME_CONVERTER.convert(name());
        }
    }

    /** Options for logging the Ant task's progress. */
    public enum LogPolicy {
        NONE(-1),
        ERR(MSG_ERR),
        WARN(MSG_WARN),
        INFO(MSG_INFO),
        VERBOSE(MSG_VERBOSE),
        DEBUG(MSG_DEBUG);

        private final int level;

        LogPolicy(int level) {
            this.level = level;
        }
    }

    /**
     * Runs the CLDR-to-ICU Ant task with default properties and no logging. This is equivalent to
     * something like the command line:
     * <pre>{@code
     * ant -f build-icu-data.xml &> /dev/null
     * }</pre>
     *
     * <p>The CLDR_DIR environment variable must be set for the process running this code in exactly
     * the same way it is set for running the Ant script from the command line.
     *
     * @param baseDir The base ICU directory containing the build-icu-data.xml file to be invoked.
     */
    public static boolean runQuietly(Path baseDir) {
        return runCldrToIcu(baseDir, ImmutableMap.of(), LogPolicy.NONE, empty(), empty());
    }

    /**
     * Runs the CLDR-to-ICU Ant task with the specified properties and logging configuration.
     *
     * <p>The CLDR_DIR environment variable must be set for the process running this code in exactly
     * the same way it is set for running the Ant script from the command line.
     *
     * @param baseDir The base ICU directory containing the build-icu-data.xml file to be invoked.
     * @param properties A map of properties corresponding exactly to the properties defined in the
     *     build-icu-data.xml (and equivalent to command line arguments you would give to Ant).
     * @param logPolicy The log level for reporting issue. If {@code NONE} then no logging occurs.
     * @param out The output stream for informational log messages (uses STDOUT if not specified).
     * @param err The output stream for error messages (uses STDERR if not specified).
     */
    public static boolean runCldrToIcu(
        Path baseDir,
        Map<AntProperty, String> properties,
        LogPolicy logPolicy,
        Optional<PrintStream> out,
        Optional<PrintStream> err) {

        Path buildXml = baseDir.resolve(BUILD_XML);
        checkArgument(Files.exists(buildXml), "could not find build file: %s", buildXml);

        Project project = new Project();
        project.setUserProperty("ant.file", buildXml.toAbsolutePath().toString());
        project.init();
        ProjectHelper helper = ProjectHelper.getProjectHelper();
        project.addReference("ant.projectHelper", helper);
        helper.parse(project, buildXml.toFile());
        if (logPolicy != LogPolicy.NONE) {
            project.addBuildListener(getDefaultLogger(logPolicy, out, err));
        }
        project.setBaseDir(baseDir.toFile());
        properties.forEach((k, v) -> project.setProperty(k.getPropertyName(), v));
        try {
            project.executeTarget(project.getDefaultTarget());
        } catch (BuildException e) {
            err.orElse(System.err).println(e);
            e.printStackTrace(err.orElse(System.err));
            return false;
        }
        return true;
    }

    private static DefaultLogger getDefaultLogger(
        LogPolicy level, Optional<PrintStream> out, Optional<PrintStream> err) {
        DefaultLogger consoleLogger = new DefaultLogger();
        consoleLogger.setOutputPrintStream(out.orElse(System.out));
        consoleLogger.setErrorPrintStream(err.orElse(System.err));
        consoleLogger.setMessageOutputLevel(level.level);
        return consoleLogger;
    }
}
